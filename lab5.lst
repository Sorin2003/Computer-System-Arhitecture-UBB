     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ;A: 2, 1, 3, 3, 4, 2, 6
    14                                      ;B: 4, 5, 7, 6, 2, 1
    15                                      ;R: 1, 2, 6, 7, 5, 4, 1, 3, 3
    16 00000000 02010303040206              A db 2, 1, 3, 3, 4, 2, 6
    17 00000007 040507060201                B db 4, 5, 7, 6, 2, 1
    18                                      lA equ $ - A - B
    19                                      lB equ $ - B
    20 0000000D 00<rept>                    R times lA db 0
    21                                  ; our code starts here
    22                                  segment code use32 class=code
    23                                      start:
    24 00000000 B906000000                  mov ecx, lA
    25                                          ;Two byte strings A and B are6 given. Obtain the string R by concatenating the elements of B in reverse order and the odd elements of A.
    26 00000005 31F6                            xor esi,esi ;put esi on 0 so i can use it for the loops
    27 00000007 BF06000000                      mov edi, lB ;mov the lenght of B in edi so we can use it to start from the last element
    28                                          reverse_B:                ;loop for the reversed elements of B
    29 0000000C 8A87[06000000]                      mov al, [B + edi - 1] ;element of B in al starting from the last element because [B + edi] edi being the lenght of B in the beginning
    30 00000012 8886[0D000000]                      mov [R + esi], al     ;moving the element in R
    31 00000018 46                                  inc esi               ;esi + 1 so we add to the next poz
    32 00000019 4F                                  dec edi               ;edi - 1 so we get the previous poz
    33 0000001A 83FE06                              cmp esi, lB           ;verify if we're done sets zf to 1 if esi = lB (cf = 1 if lower)
    34 0000001D 72ED                            jb reverse_B              ;jump if cf = 1
    35 0000001F 31FF                            xor edi,edi               ;put edi on 0 so we can use it in the loop
    36                                          odd_A:                    ;loop for the odd elements of a
    37 00000021 8A87[00000000]                      mov al, [A + edi]     ;element of A in al
    38 00000027 A801                                test al, 1            ;set zf to and pf to 1 if even and to 0 if odd
    39 00000029 740A                                jz not_odd            ;if the zf is set to 1(the number was even) then we go into not odd loop
    40 0000002B 8886[0D000000]                      mov [R + esi], al     ;if the jz didn t jump us to not_odd loop then we add the odd number to our list
    41 00000031 46                                  inc esi               ;esi+1 so we can write the next element
    42 00000032 83FF06                              cmp edi,lA            ;we check if we finished the numbers (zf is one if we're done)
    43                                              not_odd:        ;jump the number if it s even
    44 00000035 47                                      inc edi     ; we go to the next number
    45 00000036 83FF06                                  cmp edi, lA ; lA is a constant, so we do not use [l1] we check if we finished the numbers
    46 00000039 72E6                            jb odd_A  ;if zf = 1 then we jump out             
    47                                              
    48                                              
    49                                          
    50                                          ; exit(0)
    51 0000003B 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    52 0000003D FF15[00000000]                  call    [exit]       ; call exit to terminate the program
    53                                          
