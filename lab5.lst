     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ;A: 2, 1, 3, 3, 4, 2, 6
    14                                      ;B: 4, 5, 7, 6, 2, 1
    15                                      ;R: 1, 2, 6, 7, 5, 4, 1, 3, 3
    16 00000000 02010303040206              A db 2, 1, 3, 3, 4, 2, 6
    17 00000007 040507060201                B db 4, 5, 7, 6, 2, 1
    18                                      lA equ $ - A - B
    19                                      lB equ $ - B
    20 0000000D 00<rept>                    R times lA db 0
    21                                  ; our code starts here
    22                                  segment code use32 class=code
    23                                      start:
    24                                          ;Two byte strings A and B are6 given. Obtain the string R by concatenating the elements of B in reverse order and the odd elements of A.
    25 00000000 31F6                            xor esi,esi ;put esi on 0 so i can use it for the loops
    26 00000002 BF06000000                      mov edi, lB ;mov the lenght of B in edi so we can use it to start from the last element
    27                                          reverse_B:                ;loop for the reversed elements of B
    28 00000007 8A87[06000000]                      mov al, [B + edi - 1] ;element of B in al starting from the last element because [B + edi] edi being the lenght of B in the beginning
    29 0000000D 8886[0D000000]                      mov [R + esi], al     ;moving the element in R
    30 00000013 46                                  inc esi               ;esi + 1 so we add to the next poz
    31 00000014 4F                                  dec edi               ;edi - 1 so we get the previous poz
    32 00000015 83FE06                              cmp esi, lB           ;verify if we're done
    33 00000018 72ED                            jb reverse_B              ;exit if the cpm says so
    34 0000001A 31FF                            xor edi,edi               ;put edi on 0 so we can use it in the loop
    35                                          odd_A:                    ;loop for the odd elements of a
    36 0000001C 8A87[00000000]                      mov al, [A + edi]     ;element of A in al
    37 00000022 A801                                test al, 1            ;set zf to and pf to 1 if even and to 0 if odd
    38 00000024 740A                                jz not_odd            ;if the zf is set to 1(the number was even) then we go into not odd loop
    39 00000026 8886[0D000000]                      mov [R + esi], al     ;if the jz didn t jump us to not_odd loop then we add the odd number to our list
    40 0000002C 46                                  inc esi               ;esi+1 so we can write the next element
    41 0000002D 83FF06                              cmp edi,lA            ;we check if we finished the numbers (zf is one if we're done)
    42                                              not_odd:        ;jump the number if it s even
    43 00000030 47                                      inc edi     ; we go to the next number
    44 00000031 83FF06                                  cmp edi, lA ; lA is a constant, so we do not use [l1] we check if we finished the numbers
    45 00000034 72E6                            jb odd_A  ;if zf = 1 then we jump out             
    46                                              
    47                                              
    48                                          
    49                                          ; exit(0)
    50 00000036 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    51 00000038 FF15[00000000]                  call    [exit]       ; call exit to terminate the program
    52                                          
